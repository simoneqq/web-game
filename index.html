<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Gra FPS Three.js - Poprawiona</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            cursor: pointer;
            border: 2px solid #555;
        }
    </style>
</head>
<body>

    <div id="instructions">
        <h1>Kliknij, aby zacząć</h1>
        <p>W, A, S, D - Poruszanie</p>
        <p>Myszka - Rozglądanie</p>
        <p>Spacja - Skok</p>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- ZMIENNE GLOBALNE ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        const playerHeight = 1.6;
        const mapSize = 20;
        const obstacleColliders = [];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Oświetlenie
            const light = new THREE.HemisphereLight(0xeeeeff, 0x444422, 1.2);
            scene.add(light);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // STEROWANIE
            controls = new PointerLockControls(camera, document.body);
            
            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => instructions.style.display = 'none');
            controls.addEventListener('unlock', () => instructions.style.display = 'block');

            // KLUCZOWA POPRAWKA: Używamy controls.object zamiast getObject()
            scene.add(controls.object); 

            // Obsługa klawiszy
            const onKeyDown = (e) => {
                if (e.code === 'KeyW') moveForward = true;
                if (e.code === 'KeyS') moveBackward = true;
                if (e.code === 'KeyA') moveLeft = true;
                if (e.code === 'KeyD') moveRight = true;
                if (e.code === 'Space' && canJump) { velocity.y += 10; canJump = false; }
            };
            const onKeyUp = (e) => {
                if (e.code === 'KeyW') moveForward = false;
                if (e.code === 'KeyS') moveBackward = false;
                if (e.code === 'KeyA') moveLeft = false;
                if (e.code === 'KeyD') moveRight = false;
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // MAPA
            const floorGeo = new THREE.PlaneGeometry(mapSize, mapSize);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x33aa33 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // SZEŚCIANY Z TEKSTURAMI
            const loader = new THREE.TextureLoader();
            const createCube = (x, z, texPath) => {
                const tex = loader.load(texPath, undefined, undefined, () => console.log("Brak tekstury: " + texPath));
                const cube = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshStandardMaterial({ map: tex })
                );
                cube.position.set(x, 0.5, z);
                scene.add(cube);
                
                // Dodanie do kolizji
                const box = new THREE.Box3().setFromObject(cube);
                obstacleColliders.push(box);
            };

            createCube(3, 3, 'pobrane (1).jpg');
            createCube(-3, -2, 'pobrane (2).jpg');

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 30.0 * delta; // Grawitacja

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;

                // Ruch i kolizje
                const playerPos = controls.object.position;
                
                // Ruch przód/tył
                controls.moveForward(-velocity.z * delta);
                controls.moveRight(-velocity.x * delta);

                // Prosta kolizja z sześcianami
                const playerBB = new THREE.Box3().setFromCenterAndSize(
                    playerPos, new THREE.Vector3(0.6, 1.8, 0.6)
                );

                for (let box of obstacleColliders) {
                    if (playerBB.intersectsBox(box)) {
                        // Cofnięcie ruchu przy kolizji
                        controls.moveForward(velocity.z * delta);
                        controls.moveRight(velocity.x * delta);
                    }
                }

                // Grawitacja i podłoga
                playerPos.y += velocity.y * delta;

                const halfMap = mapSize / 2;
                if (playerPos.x > -halfMap && playerPos.x < halfMap && 
                    playerPos.z > -halfMap && playerPos.z < halfMap) {
                    if (playerPos.y < playerHeight) {
                        velocity.y = 0;
                        playerPos.y = playerHeight;
                        canJump = true;
                    }
                }

                // Reset po spadnięciu
                if (playerPos.y < -15) {
                    playerPos.set(0, playerHeight, 0);
                    velocity.y = 0;
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>